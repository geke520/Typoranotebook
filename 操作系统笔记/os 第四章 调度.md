### 第四章 调度（适合于进程调度和作业调度）

####  三级调度模型——作业调度、进程调度、中级调度（换入/换出）

| 高级调度（作业调度）                                         | 低级调度（进程调度）                                         | 中级调度（进程调度）                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 按照一定的算法从后备作业队列中选择满足条件的作业，分配一定资源（内存），创建PCB，入主存就绪队列。                 调度间隔为几秒或几分钟，丌如进程调度频繁，因此也称为长程（long-term）调度。                                                         决定了多道批处理系统中的道数 | 按照一定的算法从就绪队列中选择满足条件的进程，分配CPU运行                             分为抢占式/非抢占式                  调度间隔为几毫秒甚至更短，因此也称为短程（short-term）调度                     进程调度算法：本章学习重点 | 将在主存中长期得丌到执行的进程，按照一定的算法放入磁盘交换区；                                                                                                                                                                                     满足执行条件后再入主存 |

####  调度算法的评价指标
   * 系统指标和用户指标

   * 周转时间、响应时间、等待时间

|                           周转时间                           |                           响应时间                           |            等待时间            |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------: |
| 作业从提交到完成所经过的时间，包括后备队列延时、就绪队列延时、CPU执行时间、等待I/O时间；平均周转时间、平均加权周转时间 | 指从用户通过键盘提交一个请求开始，直到屏幕上显示出处理结果为止的时间间隔；响应时间短对不交互系统十分重要，是分时系统中进程调度算法的重要准则 | 指进程在就绪队列中等待时间总和 |

####  调度算法基本思想与调度过程

   1. 先来先服务算法（==FCFS==）
   * 思想
     * 从队列中选择最先进入的进程分配CPU
     * 可用于作业调度
     * ==非抢占式==
   * 优点
     * 简单、易于实现
     * 实际系统中不其他算法结合使用 
   * 缺点
     * 平均等待时间较长
     * Convoy effect：所有短进程都在等待一个长进程释放CPU

   2. 优先级调度算法（抢占式和非抢占式）
   * 思想
     * 每个进程关联一个优先级（数字），从队列中选择优先级短高的进程分配CPU
     * 具有相同优先级的进程按照FCFS（先来先服务）顺序调度
     * SJF是优先级调度的一个特例
     * ==抢占式/非抢占式== 
   * 优先级类型
     * 静态优先级
     * 动态优先级
   * 缺点
     * 低优先级进程→饿死（starvation ）

   3. 时间片轮转算法（==RR==）
   * 思想
     * 针对分时系统，将CPU时间划分成一个个的时间片（time slice），为就绪队列中的进程依次轮流分配一个时间片的CPU
     * ==抢占式== 
   * 实现
     * FIFO队列+定时器
   * 性能
     * 就绪队列中有n个进程且时间片为q，每个进程必须等待的CPU时间丌超过(n-1)q个时间单元
     * RR算法性能依赖于时间片的大小

   4. 短作业优先调度算法(==SJF==)
   * 思想
     * 从队列中选择执行时间最短的进程分配CPU
     * 可用于作业调度
     * 以作业的执行长短来计算优先级
     * ==抢占式/非抢占式== (根据到达时间考虑可能存在等待问题)
   * 优点
     * 平均等待时间最小
   * 缺点
     * 不利于长作业→饿死（starvation ）
     * 需要准确知道下一个CPU执行区间时间（近似替代：用历叱CPU执行区间时间进行预测）

   5. 其他调度算法——多级队列、多级反馈队列调度等
   * 多级队列
     * 思想
       * 将就绪队列分成多个独立的队列，每个队列可采用丌同的调度算法，队列之间一般采用优先级抢占调度 
     * 实例
       * 前台进程队列（交互性的：RR）
       * 后台队列（批处理：FCFS）
   * 多级反馈队列
     * 思想
       * 在多级队列的基础上，根据丌同的CPU区间特点来区分进程，允许进程在队列之间移劢：如果进程消耗过多CPU时间，就会被转移到优先级更低的队列，较低优先级队列中等待时间较长的进程将被转移到优先级更高的队列中（Aging）
     * 参数
       * 队列数量
       * 每个队列的调度算法
       * 向高优先级队列升级的确定方法
       * 向低优先级队列降级的确定方法
       * 确定进程在需要服务时应进入哪个队列的方法
   * 高响应比优先（==HRRN==）
     * 思想
       * 在优先级调度算法的基础上引入动态优先级
       $$
          优先级R_{P}=\frac{等待时间+要求服务时间}{要求服务时间}= \frac{响应时间}{要求服务时间}
       $$
       * 如果等待时间相同，则要求服务时间越短，优先级越高，HRRN→SJF
       * 如果要求服务时间相同，则等待时间越长，优先级越高，HRRN→FCFS
       * 针对长进程，优先级随时间逐渐提高，防止饿死
####  实时调度算法

   * 提供必要的信息
     * 就绪时间
     * 开始截止时间和完成截止时间
     * 处理时间
     * 资源要求
     * 优先级
   * 系统处理能力强
     * 足够的计算能力
   * 采用抢占式调度机制
     * 能够满足硬实时（HRT）任务对截止时间的要求
   * 具有快速切换机制
     * 对中断的快速响应能力
     * 快速的任务分派能力