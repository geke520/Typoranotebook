### 第七章 存储管理
#### 存储管理的功能
* 主存空间的分配与管理
* 地址转换与重定位(静态重定位、动态重定位)
  * 重定位：从逻辑地址（虚拟地址）到物理地址的映射称为重定位，由内存管理单元（MMU）完成
* 存储保护与共享
* 存储扩充
#### 程序装入和链接方法
* 装入方式
  * 绝对装入（Absolute Loading）
    事先已经知道用户程序入主存后的位置，编译程序在编译时就完成静态重定位，即将相对地址修改为绝对地址，装入程序按照装入模块中的地址，将程序和数据装入内存
  * 可重定位装入（Relocation Loading）
    多道环境下，编译程序不能预知用户程序入主存后的位置，因此编译后的目标模块的起始地址一般设为从0开始。可重定位装入程序根据内存使用情况，将装入模块进行静态重定位后装入内存
  * 动态运行时装入（Dynamic Run-time Loading） 
    装入程序将装入模块装入内存后，不将装入模块中的逻辑地址修改为物理地址，而是在执行时在重定位寄存器的辅助下再进行动态重定位
* 链接方式
  * 静态链接（Static Linking）
    * 程序运行之前，现将各目标模块以及所需库函数链接成一个完整的装入模块
    * 要解决的问题
      * 修改相对地址
      * 将外部调用符号变换为相对地址
  * 装入时动态链接（Load-time Dynamic Linking）
    * 将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式
    * 优点
      * 便于修改和更新目标模块
      * 实现对某些目标模块的共享
  * 运行时动态链接（Run-time Dynamic Linking）
    * 将对某些目标模块的链接推迟到程序执行时才进行
    * 有些目标模块（如错误处理）如果在执行过程中未被用到甚至不会被装入内存和进行链接
    * 不仅能加快装入过程，而且还能节省内存空间
#### 存储管理的基本概念——逻辑地址、物理地址、重定位
#### 存储管理方法——连续内存空间管理方法
   1. 固定分区管理

      * 分区划分

        * 分区大小相等

        * 分区大小不等

      * 内存分配

      * 内碎片（Internal Fragmentation）

   2. 可变分区管理

      为进程选择合适的可用分区（hole）：动态分区分配
      算法。

      * 首次适应（First Fit）：从头开始找到的第一个足够大的分区
      * 循环首次适应（Next Fit）：首次适应的变种，从上次找到的位置继续往下找，找到的第一个足够大的分区
      * 最佳适应（Best Fit）：搜索所有可用分区，找到的足够大但却最小的分区
      * 最差适应（Worst Fit）：搜索所有可用分区，找到的最大的分区
      * 首次适应和最佳适应算法在执行时间和空间利用方面都优于最差适应算法，首次适应算法执行最快

   3. 动态重定位分区管理——紧凑概念

   4. 覆盖与交换技术

      当内存空间紧张时，系统将内存中某些进程暂时移到外存（盘交换
      区），把外存中某些进程换入内存中，替换移出进程原来的内存空间。这种技术是进程在内存与外存之间的动态调度，多用于分时系统中。中级调度：采用交换技术
#### 存储管理方法——离散内存空间管理方法
   1. 分页存储管理方式——基本思想、基本地址变换、有效访问时间

      * 基本思想：

        * 内存物理地址空间按2n 等分成页框/帧（frame），并从0连续编号：0,1,2,...

        * 作业的逻辑地址空间按页框/帧大小等分成页，并从0连续编号：0,1,2,...

        * 作业逻辑地址表示为：v=(p,d)

        * 作业连续的页，可以分配不连续的页框/帧

        * 系统设置页表PMT保存作业各页入内存后的情况，包含页号、页框号

        * 设置一个页表地址寄存器，保存当前执行进程页表的起始地址和页表的长度
      * 基本地址变换
        * 借助页表、页表寄存器完成作业的逻辑地址（虚地址）到内存物理地址的变换
        * 页表基址寄存器（ Page-table base register，PTBR） 页表长度寄存器（ Page-table length register，PRLR）
      * 有效访问时间
        例：快表的访问时间为20ns，内存访问时间为100ns，若从快表中找到的概率（即命中率）为80%，
则有效访问时间为多少？
解： 不使用快表的访问时间为：
$$
t=100×2ns
$$
​                      有效访问时间为：
$$
t=20\%×(20+100*2)+80\%×(20+100)=140ns
$$

   2. 分段存储管理方式——基本思想、分段和分页的区别、段的共享与保护、段的动态链接
      段：一组逻辑信息的集合。如：主程序段、子程序段、数据段、堆栈段等

      * 基本思想：

        * 作业的逻辑地址空间分段，每个段有自己的段名，并从0连续编号：0,1,2,...
        * 装入程序将分段装入时，为每一个分段分配一段号
        * 作业逻辑地址表示：v=(s,d)
        * 以段为单位分配主存，每一分段分配连续的分区
        * 系统设置段保存作业各段入内存后的情况：主要有包括段号、段长、主存起址
        * 设置一个段表地址寄存器，保存当前执行进程段表的起始地址和长度

      * 段的共享与保护
        * 段的保护
          * 段表基址寄存器STBR和段表长度寄存器STLR
          * 与段相关的保护位：只读、只写、只执行
          * 与段相关的Validation位：为0表示不合法段
        * 段的共享
          * 设置共享段表
          * 第一个请求使用共享段的进程申请内存分区，调入，修
            改共享段表内容
          * 后续进程使用共享段，在本进程段表填入共享段物理地
            址；在共享段表中增加表目，将共享段计数count加1
          * 回收执行count-1
          * count=0时撤销该共享段

      * **分段和分页的区别**

        （1） 页是信息的物理单位，为实现离散存储，提高内存利用率而引入；段是信息的逻辑单位，为满足用户要求而引入

        （2）页的大小固定且由系统确定；而段长不定，取决于用户程序，并在编译时划分

        （3）分页的作业地址空间是一维的；分段的作业地址空间是二维的

   3. 段页式存储管理方式
      * 内存物理地址空间等分成页框，并从0连续编号
      * 作业的逻辑地址分段
      * 作业各段按页框大小等分成页，并从0连续编号
      * 作业逻辑地址表示：v=(s, p, d)
      * 作业各段连续的页，可以分配不连续的页框
      * 系统为每个作业设置一个段表，每个分段再设置一个页表，分别保存作业各段及每段各页入内存后的情况
        * 段表包括段号、该段页表起址、该段页表长度
        * 页表包括页号、页框号
      * 设置一个段表地址寄存器，保存当前执行进程段表的起始地址和段表的长度